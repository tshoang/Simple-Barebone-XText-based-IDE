/*
 * generated by Xtext 2.15.0
 */
package ac.soton.java.barebones.generator

import ac.soton.java.barebones.bareBones.Clear
import ac.soton.java.barebones.bareBones.Decrement
import ac.soton.java.barebones.bareBones.Increment
import ac.soton.java.barebones.bareBones.Program
import ac.soton.java.barebones.bareBones.Statement
import ac.soton.java.barebones.bareBones.While
import java.util.HashMap
import java.util.Map
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class BareBonesGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val program = resource.contents.get(0)
		val heap = new HashMap<String, Integer>(); 
		if (program instanceof Program) {
			val contents = program.eContents
			contents.forEach [ content |
				if (content instanceof Statement) {
					val statement = content as Statement
					execute(statement, heap)
				}
			]
		}
			
		fsa.generateFile('result.txt', heap.toString())
	}
		
	def execute(Statement statement, Map<String, Integer> heap) {
		if (statement instanceof Clear) {
			executeClear(statement, heap)
		} else if (statement instanceof Increment) {
			executeIncr(statement, heap)
		} else if (statement instanceof Decrement) {
			executeDecr(statement, heap)
		} else if (statement instanceof While) {
			executeWhile(statement, heap)
		} else {
			throw new UnsupportedOperationException("Unknown statement " + statement)
		}		
	}
		
	def executeWhile(While statement, Map<String, Integer> heap) {
		val name = statement.name
		if (heap.containsKey(name)) {
			var value = heap.get(name)
			val nestedStatements = statement.statements
			while (value != 0) {
				nestedStatements.forEach[nestedStatement |
					val stm = nestedStatement as Statement
					execute(stm, heap)
				]
				value = heap.get(name)
			}
		}
		else {
			throw new UnsupportedOperationException("Cannot use undeclared variable " + name + " for loop")
		}
	}
		
	def executeDecr(Decrement statement, Map<String, Integer> heap) {
		val name = statement.name
		if (heap.containsKey(name)) {
			val value = heap.get(name)
			if (value == 0)
				throw new UnsupportedOperationException("Cannot decrease further " + statement)		
			else {
				heap.put(name, value - 1)
			}
		} else {
			throw new UnsupportedOperationException("Cannot decrease undeclared variable " + name)
		}
	}
		
	def executeIncr(Increment statement, Map<String, Integer> heap) {
		val name = statement.name
		if (heap.containsKey(name)) {
			val value = heap.get(name)
			heap.put(name, value + 1)
		} else {
			throw new UnsupportedOperationException("Cannot increase undeclared variable " + name)
		}
	}
		
	def executeClear(Clear statement, Map<String, Integer> heap) {
		val name = statement.name
		heap.put(name, 0)
	}
}
